name: CI/CD Pipeline

on:
  push: 
    branches: [main]

  pull_request:
    branches: [main]

  workflow_dispatch: #Ручной запуск workflow

jobs:
  build:
    runs-on: self-hosted

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Clear container
      run: |
        docker compose down

    - name: .env File 
      run: | #Here document, либо echo для каждой строки
        cat >> .env << EOF 
        DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
        DATABASE_HOST=${{ secrets.DATABASE_HOST }}
        DATABASE_NAME=${{ secrets.DATABASE_NAME }}
        DATABASE_USER=${{ secrets.DATABASE_USER }}
        DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
        DATABASE_PORT=${{ secrets.DATABASE_PORT }}
        DATABASE_AUTH=${{ secrets.DATABASE_AUTH }}
        APP_PORT=${{ secrets.APP_PORT }}
        EOF

    - name: Docker-compose 
      run: |
        docker compose up -d --build
        sleep 60
        docker compose ps

    - name: Run Django migrations
      run: |
        docker compose exec web python myproject/manage.py migrate
    
    - name: Check_containers
      run: |
        if docker-compose ps | grep -q "Up"; then
          echo "All containers are running"
        else
          echo "Some containers failed to start"
          docker-compose logs
          exit 1
        fi

    - name: 1 Test
      run: |
        if curl -f http://localhost:${{ secrets.APP_PORT }}; then
          echo "Web application is healthy"
        else
          echo "Web application health check failed"
        exit 1
        fi

        # Если /check_db возвращает любой ответ без ошибок - считаем что БД работает
        if curl -s -f http://localhost:${{ secrets.APP_PORT }}/check_db; then
          echo "Database connection working"
        else
          echo "Database connection failed"
          exit 1
        fi
    
    - name: 2 Test
      run: |
        # Получаем количество записей через веб-интерфейс (из HTML)
        WEB_RESPONSE=$(curl -s http://localhost:${{ secrets.APP_PORT }})
        WEB_COUNT=$(echo "$WEB_RESPONSE" | grep -o 'Всего записей в таблице: <strong>[0-9]*' | grep -o '[0-9]*$')
        
        # выдает чистое число без пробелов
        DB_COUNT=$(docker compose exec -T db mysql -u${{ secrets.DATABASE_USER }} -p${{ secrets.DATABASE_PASSWORD }} ${{ secrets.DATABASE_NAME }} -s -N -e "SELECT COUNT(*) FROM myapp_counter;" | tr -d ' ')
    

        echo "Database count: $DB_COUNT"
        echo "Web interface count: $WEB_COUNT"
        
        if [ "$DB_COUNT" = "$WEB_COUNT" ]; then
          echo "test passed"
        else
          echo "test failed"
          exit 1
        fi

    - name: Create test report
      run: |
        cat > test-report.md << EOF
        # Deployment Test Report
        - Date: $(date)
        - Application: Healthy ✅
        - Database: Connected ✅
        - Data Consistency: Passed ✅
        - Containers: Running ✅
        ## Environment Variables
        - DATABASE_HOST: ${{ secrets.DATABASE_HOST }}
        - DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
        - APP_PORT: ${{ secrets.APP_PORT }}
        EOF

    - name: Save Docker logs
      if: always()
      run: |
        docker compose logs > deployment-logs.txt
        docker images > docker-images.txt
        docker ps -a > docker-ps.txt

    - name: Upload Docker logs as artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-logs
        path: |
          deployment-logs.txt
          docker-images.txt
          docker-ps.txt
        retention-days: 30
          
    - name: Save artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-artifacts
        path: |
          .env
          test-report.md
          deployment-logs.txt
        retention-days: 30
      
    - name: Check if .env exists
      run: |
        ls -la
        if [ -f ".env" ]; then
          echo ".env file exists"
          cat .env
        else
          echo ".env file does not exist"
          exit 1
        fi
